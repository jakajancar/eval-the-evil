#!/usr/bin/env node
const child_process = require('child_process');
const fs = require('fs');
const net = require('net');
const assert = require('assert');

const tests = [].concat(
    /***** Binary compatibilites *****/
    [{title: `Binary is linked only against very common dynamic libraries`, func: async () => {
        // These are what node.js uses (from node-v10.16.0-linux-x64).
        // If it's good enough for them, it's good enough for us.
        const nodeJsLibs = [
            'linux-vdso.so.1',
            'libdl.so.2',
            'librt.so.1',
            'libstdc++.so.6',
            'libm.so.6',
            'libgcc_s.so.1',
            'libpthread.so.0',
            'libc.so.6',
            '/lib64/ld-linux-x86-64.so.2',
        ];

        const result = child_process.spawnSync('ldd', ['build/eval-the-evil']);
        assert(result.status === 0);

        const ourLibs = result.stdout.toString().trim().split('\n').map(x => x.trim().split(' ')[0]);
        for (const lib of ourLibs) {
            assert(nodeJsLibs.indexOf(lib) !== -1, `We require ${lib}, which node.js does not.`);
        }
    }}],

    /***** Bad request errors *****/
    [{title: `Returns correct error if request is not JSON`, func: async () => {
        assert.deepStrictEqual(await call('not json', true), {status: 'bad_request', detail: "Request is not valid JSON."});
    }}],
    ["hello world", 42, true, null, /* [] todo */].map( value => (
        {title: `Returns correct error if request is not an object (${JSON.stringify(value)})`, func: async () => {
            assert.deepStrictEqual(await call(value), {status: 'bad_request', detail: "Request is not an object."});
        }}
    )),
    [{title: `Returns correct error if code is missing`, func: async () => {
        assert.deepStrictEqual(await call({context: {}}), {status: 'bad_request', detail: "Missing 'code' parameter or it is not a string."});
    }}],
    [{title: `Returns correct error if code is missing`, func: async () => {
        assert.deepStrictEqual(await call({context: {}}), {status: 'bad_request', detail: "Missing 'code' parameter or it is not a string."});
    }}],
    [{title: `Returns correct error if context is missing`, func: async () => {
        assert.deepStrictEqual(await call({code: ''}), {status: 'bad_request', detail: "Missing 'context' parameter or it is not an object."});
    }}],

    /***** Computation *****/
    [{title: `Computes 1 (code) + 1 (context)`, func: async () => {
        assert.deepStrictEqual(await call({code: 'return 1+i', context: {i: 1}}), {status: 'success', return_value: 2});
    }}],

    /***** Environment *****/
    [{title: `Provides a 'global' object self-reference`, func: async () => {
        assert.deepStrictEqual(await call({code: 'x = 1; return global.x + 1', context: {}}), {status: 'success', return_value: 2});
    }}],
    [{title: `User-provided context overrides implicit context`, func: async () => {
        assert.deepStrictEqual(await call({code: 'return global === 42', context: {global: 42}}), {status: 'success', return_value: true});
    }}],
    [{title: `Does not provide async functions in scope`, func: async () => {
        assert.deepStrictEqual(await call({code: 'return typeof setTimeout === "undefined" && typeof setInterval === "undefined"', context: {}}), {status: 'success', return_value: true});
    }}],

    /***** Code error handling *****/
    [{title: `Returns parse errors`, func: async () => {
        const code = 'hello!';
        const detail = [
            `Uncaught SyntaxError: Unexpected token ! [<user-code>:1]`,
            '',
            `Stack trace:`,
            `SyntaxError: Unexpected token !`,
        ].join('\n');
        assert.deepStrictEqual(await call({code, context: {}}), {status: 'code_error', detail});
    }}],
    [{title: `Returns only user frames when throwing an error`, func: async () => {
        const code = 'function foo() { throw new Error("my message") }; foo();';
        const detail = [
            'Uncaught Error: my message [<user-code>:1]',
            '',
            'Stack trace:',
            'Error: my message',
            '    at foo (<user-code>:1:24)',
            '    at <user-code>:1:51'
        ].join('\n');
        assert.deepStrictEqual(await call({code, context: {}}), {status: 'code_error', detail});
    }}],
    [{title: `Returns sensible error when throwing null`, func: async () => {
        const code = 'throw null';
        const detail = [
            'Uncaught null [<user-code>:1]',
            '',
            'Stack trace:',
            '<no stack trace>'
        ].join('\n');
        assert.deepStrictEqual(await call({code, context: {}}), {status: 'code_error', detail});
    }}],
    [{title: `Returns sensible error when throwing random unserializable object`, func: async () => {
        const code = 'throw Math';
        const detail = [
            'Uncaught #<Object> [<user-code>:1]',
            '',
            'Stack trace:',
            '<no stack trace>'
        ].join('\n');
        assert.deepStrictEqual(await call({code, context: {}}), {status: 'code_error', detail});
    }}],

    /***** Data type support *****/
    ["hello world", "ðŸ˜¬", 42, 1e9, 1.7, true, false, null, [], [1,2,3], {}, {a: 1, b: {}, c: []}].map( value => (
        {title: `Can round-trip any datatype from json.org (${JSON.stringify(value)})`, func: async () => {
            assert.deepStrictEqual(await call({code: 'return foo', context: {foo: value}}), {status: 'success', return_value: value});
        }}
    )),

    /***** Performance *****/
    // TODO: do 100k for a real stress test
    [{title: `Handles 100 requests in series`, func: async () => {
        for (let i = 0; i < 100; i++) {
            assert.deepStrictEqual(await call({code: `return i + ${i}`, context: {i: i}}), {status: 'success', return_value: 2*i});
        }
    }}],
    [{title: `Handles 100 requests in parallel`, func: async () => {
        let promises = [];
        for (let i = 0; i < 100; i++) {
            const expected = {status: 'success', return_value: 2*i};
            const promise = call({code: `return i + ${i}`, context: {i: i}})
                            .then((actual) => { assert.deepStrictEqual(actual, expected); } );
            promises.push(promise);
        }
        return Promise.all(promises);
    }}],
);

// Poor man's test runner
async function main() {
    process.stdout.write('Starting server...');
    const subprocess = child_process.spawn('build/eval-the-evil');
    process.on('exit', () => { subprocess.kill(); });
    while (!somebodyListeningOnPort(3825)) {
        await new Promise(resolve => setTimeout(resolve, 100));
    }
    process.stdout.write(' done.\n');

    process.stdout.write('Running tests\n');
    for (const {title, func} of tests) {
        process.stdout.write(`  - ${title}...`);
        try {
            const start = +new Date;
            await func();
            const duration = new Date - start;
            process.stdout.write(` \x1b[32mpass\x1b[0m in ${duration} ms\n`);
        } catch (e) {
            process.stdout.write(` \x1b[31mfail\x1b[0m\n`);
            console.error(e.stack);
            process.exit(1);
        }
    }
    process.stdout.write('All tests passed.\n');
    process.exit(0);
}

main();

function somebodyListeningOnPort(port) {
    const hex = (port).toString(16).toUpperCase().padStart(4, 0);
    return fs.readFileSync('/proc/net/tcp', 'utf-8').split('\n')
        .filter(x => x.match('^\\s*\\d+:\\s+\\d+:' + hex + ' ')).length > 0;
}

function call(request, raw = false) {
    return new Promise(function(resolve, reject) {
        let buffer = '';
        const socket = new net.Socket();
        socket.connect(3825, '127.0.0.1', () => { socket.end(raw ? request : JSON.stringify(request)); });
        socket.on('data', (chunk) => { buffer+= chunk; });
        socket.on('end', () => { resolve(JSON.parse(buffer)); });
        socket.on('error', reject);
    });
}
